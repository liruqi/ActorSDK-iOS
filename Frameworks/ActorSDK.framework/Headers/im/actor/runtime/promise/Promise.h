//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/liruqi/Documents/github/actor-platform/actor-sdk/sdk-core/runtime/runtime-shared/src/main/java/im/actor/runtime/promise/Promise.java
//

@import j2objc;

#pragma push_macro("INCLUDE_ALL_ImActorRuntimePromisePromise")
#ifdef RESTRICT_ImActorRuntimePromisePromise
#define INCLUDE_ALL_ImActorRuntimePromisePromise 0
#else
#define INCLUDE_ALL_ImActorRuntimePromisePromise 1
#endif
#undef RESTRICT_ImActorRuntimePromisePromise

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (ARPromise_) && (INCLUDE_ALL_ImActorRuntimePromisePromise || defined(INCLUDE_ARPromise))
#define ARPromise_

@class ARPromiseResolver;
@class JavaLangException;
@protocol ARConsumer;
@protocol ARConsumerDouble;
@protocol ARFunction;
@protocol ARPromiseFunc;
@protocol ARSupplier;

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

/*!
 @brief Promise support implementations.
 It is much more like js promises than traditional
 java/scala versions.
 */
@interface ARPromise : NSObject

#pragma mark Public

/*!
 @brief Default constructor of promise
 @param executor Executor
 */
- (instancetype)initWithExecutor:(id<ARPromiseFunc>)executor;

/*!
 @brief Called after success or failure
 @param afterHandler after handler
 @return this
 */
- (ARPromise *)afterWithARConsumerDouble:(id<ARConsumerDouble>)afterHandler;

- (ARPromise *)afterVoid:(id<ARSupplier>)promiseSupplier;

/*!
 @brief Chaining result to next promise and returning current value as result promise
 @param res chaining function
 @return promise
 */
- (ARPromise *)chainWithARFunction:(id<ARFunction>)res;

/*!
 @brief Handling failure
 @param failure supplier for exception
 @return this
 */
- (ARPromise *)failure:(id<ARConsumer>)failure;

/*!
 @brief Failed promise.
 Have result immediately.
 @param e   fail reason
 @return promise
 */
+ (ARPromise *)failure:(JavaLangException *)e;

- (ARPromise *)fallback:(id<ARFunction>)catchThen;

/*!
 @brief Map result of promise to promise of value
 @param res mapping function
 @return promise
 */
- (ARPromise *)flatMap:(id<ARFunction>)res;

- (ARPromise *)log:(NSString *)TAG;

/*!
 @brief Mapping result value of promise to another value
 @param res mapping function
 @return promise
 */
- (ARPromise *)map:(id<ARFunction>)res;

- (ARPromise *)mapIfNull:(id<ARSupplier>)producer;

- (ARPromise *)mapIfNullPromise:(id<ARSupplier>)producer;

/*!
 @brief Pipe result to resolver
 @param resolver destination resolver
 @return this
 */
- (ARPromise *)pipeTo:(ARPromiseResolver *)resolver;

/*!
 @brief Success promise.
 Have result immediately.
 @param val success value
 @return promise
 */
+ (ARPromise *)success:(id)val;

/*!
 @brief Handling successful result
 @param then supplier for result
 @return this
 */
- (ARPromise *)then:(id<ARConsumer>)then;

#pragma mark Package-Private

/*!
 @brief Called when promise ended with error
 @param e error
 */
- (void)errorWithJavaLangException:(JavaLangException * __nonnull)e;

/*!
 @brief Called when result is ready
 @param res result
 */
- (void)resultWithId:(id __nullable)res;

/*!
 @brief Trying complete promise with error
 @param e error
 */
- (void)tryErrorWithJavaLangException:(JavaLangException * __nonnull)e;

/*!
 @brief Trying complete promise with result
 @param res result
 */
- (void)tryResultWithId:(id __nullable)res;

@end

J2OBJC_EMPTY_STATIC_INIT(ARPromise)

FOUNDATION_EXPORT ARPromise *ARPromise_success_(id val);

FOUNDATION_EXPORT ARPromise *ARPromise_failure_(JavaLangException *e);

FOUNDATION_EXPORT void ARPromise_initWithExecutor_(ARPromise *self, id<ARPromiseFunc> executor);

FOUNDATION_EXPORT ARPromise *new_ARPromise_initWithExecutor_(id<ARPromiseFunc> executor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ARPromise *create_ARPromise_initWithExecutor_(id<ARPromiseFunc> executor);

J2OBJC_TYPE_LITERAL_HEADER(ARPromise)

@compatibility_alias ImActorRuntimePromisePromise ARPromise;

#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#endif

#if !defined (ARPromise_PromiseCallback_) && (INCLUDE_ALL_ImActorRuntimePromisePromise || defined(INCLUDE_ARPromise_PromiseCallback))
#define ARPromise_PromiseCallback_

@class JavaLangException;

@protocol ARPromise_PromiseCallback < NSObject, JavaObject >

- (void)onResult:(id)t;

- (void)onError:(JavaLangException *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(ARPromise_PromiseCallback)

J2OBJC_TYPE_LITERAL_HEADER(ARPromise_PromiseCallback)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ImActorRuntimePromisePromise")
